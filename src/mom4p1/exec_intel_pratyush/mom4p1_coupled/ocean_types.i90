!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                   !!
!!                   GNU General Public License                      !!
!!                                                                   !!
!! This file is part of the Flexible Modeling System (FMS).          !!
!!                                                                   !!
!! FMS is free software; you can redistribute it and/or modify       !!
!! it and are expected to follow the terms of the GNU General Public !!
!! License as published by the Free Software Foundation.             !!
!!                                                                   !!
!! FMS is distributed in the hope that it will be useful,            !!
!! but WITHOUT ANY WARRANTY; without even the implied warranty of    !!
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     !!
!! GNU General Public License for more details.                      !!
!!                                                                   !!
!! You should have received a copy of the GNU General Public License !!
!! along with FMS; if not, write to:                                 !!
!!          Free Software Foundation, Inc.                           !!
!!          59 Temple Place, Suite 330                               !!
!!          Boston, MA  02111-1307  USA                              !!
!! or see:                                                           !!
!!          http://www.gnu.org/licenses/gpl.txt                      !!
!!                                                                   !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! The include file fms_platform.h will handle the conversion of POINTER to ALLOCATABLE arrays
! for derived type members. The conversion affects performance only and should not change
! any numeric result. It is limited to member arrays that are used within MOM4 only
! and to arrays that are never associated (=>) with another array.

! Fortran 90 requires array members of derived type to have the POINTER attribute.
! However, most Fortran 95 compilers now also support ALLOCATABLE array components
! (a Fortran 2003 feature). This avoids the aliasing problem afflicting pointers.
! Some compilers may require an additional switch (e.g. -fno-alias) to fully exploit
! the performance benefit of the conversion.
!
! Macros used from fms_platform.h:
! _ALLOCATABLE maps to either POINTER  or ALLOCATABLE
! _NULL        maps to either =>NULL() or "nothing"



! -*-f90-*-*
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                   !!
!!                   GNU General Public License                      !!
!!                                                                   !!
!! This file is part of the Flexible Modeling System (FMS).          !!
!!                                                                   !!
!! FMS is free software; you can redistribute it and/or modify       !!
!! it and are expected to follow the terms of the GNU General Public !!
!! License as published by the Free Software Foundation.             !!
!!                                                                   !!
!! FMS is distributed in the hope that it will be useful,            !!
!! but WITHOUT ANY WARRANTY; without even the implied warranty of    !!
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the     !!
!! GNU General Public License for more details.                      !!
!!                                                                   !!
!! You should have received a copy of the GNU General Public License !!
!! along with FMS; if not, write to:                                 !!
!!          Free Software Foundation, Inc.                           !!
!!          59 Temple Place, Suite 330                               !!
!!          Boston, MA  02111-1307  USA                              !!
!! or see:                                                           !!
!!          http://www.gnu.org/licenses/gpl.txt                      !!
!!                                                                   !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!




!parallel machine types




!most compilers support Cray pointers
!if you find a compiler that doesn't, #undef this inside a suitable #ifdef


!values of kind: double and long are 8-byte, float and int are 4-byte
!pointer_kind is used for storing addresses as integers

!these might be different on non-SGICRAY, I believe
! Warning: these numbers may not map to byte sizes for all compilers







!DEC$ MESSAGE:'Using 8-byte addressing'








!Cray XT compilers do not support real*16 computation
!also known as 128-bit or quad precision













!DEC$ MESSAGE:'Using PURE'




!DEC$ MESSAGE:'Converting pointers to allocatable components'







! 


module ocean_types_mod
!
!<CONTACT EMAIL="Matthew.Harrison@noaa.gov"> Matt Harrison
!</CONTACT>
!
!<CONTACT EMAIL="Stephen.Griffies@noaa.gov">
! S. M. Griffies
!</CONTACT>
!
!<REVIEWER EMAIL="Alexander.Pletzer@noaa.gov">
! Alexander Pletzer
!</REVIEWER>
!
!<OVERVIEW>
! This module contains type declarations and default values for ocean model.
!</OVERVIEW>
!
!<DESCRIPTION>
! This module contains type declarations and default values for ocean model.
! Multiple model realizations need to be distinguished by
! an ensemble_id for use by the diag_manager.
!</DESCRIPTION>
!
  use coupler_types_mod,only: coupler_2d_bc_type
  use field_manager_mod,only: fm_field_name_len, fm_string_len
  use fms_mod,          only: write_version_number
  use mpp_domains_mod,  only: domain2d
  use mpp_mod,          only: FATAL, mpp_error
  use time_manager_mod, only: time_type

  implicit none

  private

  logical :: module_is_initialized=.false.
  character(len=128) :: version = &
     '$Id: ocean_types.F90,v 16.0.2.8.6.1.2.3.6.1 2009/10/14 14:37:24 smg Exp $'
  character (len=128) :: tagname = &
     '$Name: mom4p1_pubrel_dec2009_nnz $'


  type, public :: obc_flux
     real, ALLOCATABLE, dimension(:,:) :: flux     ! flux through a boundary
  end type obc_flux

  type, public :: ocean_time_steps_type
     character(len=32)  :: time_tendency      ! either "twolevel" or "threelevel"
     character(len=32)  :: barotropic_scheme  ! for diagnostic printout
     integer :: tendency ! either "TWO_LEVEL" or "THREE_LEVEL"
     real    :: aidif    ! aidif=1.0 for fully implicit vertical mixing and 0.0 for fully explicit
     real    :: acor     ! acor=0.0 for explicit Coriolis, 0.5 <= acor <= 1.0 for semi-implicit
     real    :: dtts     ! tracer timestep (seconds)
     real    :: dtuv     ! internal mode timestep (seconds)
     real    :: dtbt     ! barotropic timestep (seconds)
     real    :: dteta    ! ocean volume time step (eta_t) (seconds)
     real    :: dtime_t  ! 2*dtts  if threelevel, 1*dtts  if twolevel
     real    :: dtime_u  ! 2*dtuv  if threelevel, 1*dtuv  if twolevel
     real    :: dtime_e  ! 2*dteta if threelevel, 1*dteta if twolevel
     real    :: robert_asselin_param ! parameter used for time filtering with leap-frog scheme
  end type ocean_time_steps_type

  type, public :: ocean_options_type
     integer            :: vertmix
     character(len=72)  :: vert_mix
     character(len=72)  :: tidal_wave_mix
     character(len=72)  :: tidal_drag_mix
     character(len=72)  :: bryan_lewis_mix
     character(len=72)  :: hwf_mix
     character(len=72)  :: tanh_diff_cbt
     character(len=72)  :: horz_bih_tracer
     character(len=72)  :: horz_lap_tracer
     character(len=72)  :: horz_lap_friction
     character(len=72)  :: horz_bih_friction
     character(len=72)  :: momentum_source
     character(len=72)  :: form_drag
     character(len=72)  :: bottom_roughness
     character(len=72)  :: bmf_implicit
     character(len=72)  :: geothermal_heating
     character(len=72)  :: OBC
     character(len=72)  :: baroclinic_tendency
     character(len=72)  :: barotropic_tendency
     character(len=72)  :: tracer_tendency
     character(len=72)  :: equation_of_state
     character(len=72)  :: temperature_variable
     character(len=72)  :: frazil_ice
     character(len=72)  :: convective_adjustment
     character(len=72)  :: neutral_physics
     character(len=72)  :: submesoscale
     character(len=72)  :: sigma_transport
     character(len=72)  :: overexchange
     character(len=72)  :: mixdownslope
     character(len=72)  :: overflow
     character(len=72)  :: shortwave
     character(len=72)  :: xlandmix
     character(len=72)  :: xlandinsert
     character(len=72)  :: rivermix 
     character(len=72)  :: riverspread
     character(len=72)  :: passive_tracers
     character(len=72)  :: ocean_sponges_eta
     character(len=72)  :: ocean_sponges_tracer
     character(len=72)  :: ocean_sponges_velocity
  end type ocean_options_type



! This file contains some commonly used indices
! needed for setting up the various domains in mom4.
!
! The MOM4_STATIC_ARRAYS preprocessor option sets these
! indices according to values specified at compile time,
! whereas dynamic memory determines the indices at runtime.
!
! Dynimical allocation is more conveneient as it allows one to
! make changes to the model grid configuration without recompiling.
! However, on some platforms, use of static allocated arrays,
! whose size is set at runtime, provides for a more efficient
! executable.  Tests should be run to determine if significant
! differences exist on your specific computer and model
! configuration.
!



  integer :: isd
  integer :: ied
  integer :: jsd
  integer :: jed
  integer :: isc
  integer :: iec
  integer :: jsc
  integer :: jec
  integer :: isg
  integer :: ieg
  integer :: jsg
  integer :: jeg
  integer :: ni
  integer :: nj
  integer :: nk





!############################################################################################
! not MOM4_STATIC_ARRAYS

  type, public :: ocean_thickness_type
     integer :: method       ! energetic or finite volume

     real, dimension(:,:,:,:), ALLOCATABLE :: rho_dzt    ! rho(kg/m^3)*thickness(m) of T cell at 3 times
     real, dimension(:,:,:),   ALLOCATABLE :: rho_dztr   ! 1.0/(rho*dzt) at time taup1
     real, dimension(:,:,:,:), ALLOCATABLE :: rho_dzu    ! rho(kg/m^3)*thickness(m) of U cell at 3 times
     real, dimension(:,:,:),   ALLOCATABLE :: rho_dzur   ! 1.0/(rho*dzu) at time taup1

     real, dimension(:,:,:),   ALLOCATABLE :: rho_dzt_tendency  ! rho_dzt tendency (kg/m^3)*(m/s)

     real, dimension(:,:),     ALLOCATABLE :: sea_lev  ! eta_t + patm/(rho0*grav) (m) at time taup1 for coupler
     real, dimension(:,:,:),   ALLOCATABLE :: dzt      ! thickness of T cell (m) at time tau/taup1
     real, dimension(:,:,:),   ALLOCATABLE :: dzu      ! thickness of U cell (m) at time tau/taup1
     real, dimension(:,:,:),   ALLOCATABLE :: dzwt     ! vert distance (m) between T points at time tau/taup1
     real, dimension(:,:,:),   ALLOCATABLE :: dzwu     ! vert distance (m) between U points at time tau/taup1

     real, dimension(:,:,:),   ALLOCATABLE :: dztlo  ! distance (m) from T-cell point to top of T-cell
     real, dimension(:,:,:),   ALLOCATABLE :: dztup  ! distance (m) from T-cell point to bottom of T-cell

     real, dimension(:,:,:),   ALLOCATABLE :: geodepth_zt  ! vert distance (m) from z=0 to T-point
     real, dimension(:,:,:),   ALLOCATABLE :: depth_zt     ! vert distance (m) from column top to T-point
     real, dimension(:,:,:),   ALLOCATABLE :: depth_zwt    ! vert distance (m) from column top to T-bottom
     real, dimension(:,:,:),   ALLOCATABLE :: depth_zu     ! vert distance (m) from column top to U-point
     real, dimension(:,:,:),   ALLOCATABLE :: depth_zwu    ! vert distance (m) from column top to U-bottom

     real, dimension(:,:,:),   ALLOCATABLE :: depth_st     ! s-distance to T cell grid point
     real, dimension(:,:,:),   ALLOCATABLE :: depth_swt    ! s-distance to T cell grid bottom
     real, dimension(:,:,:),   ALLOCATABLE :: dst          ! s-increment of T-cell at time tau
     real, dimension(:,:,:),   ALLOCATABLE :: dswt         ! s-increment of T-point at time tau
     real, dimension(:,:,:),   ALLOCATABLE :: dzt_dst      ! T-cell specific thickness (m/s-coordinate)

     real, dimension(:,:,:),   ALLOCATABLE :: dstlo        ! s-distance (s-units) from T-cell point to top of T-cell
     real, dimension(:,:,:),   ALLOCATABLE :: dstup        ! s-distance (s-units) from T-cell point to bottom of T-cell

     real, dimension(:,:),     ALLOCATABLE :: pbot0        ! reference bottom pressure (Pa)
     real, dimension(:,:),     ALLOCATABLE :: pbot0r       ! inverse of reference bottom pressure (1/Pa)

     real, dimension(:,:,:),   ALLOCATABLE :: mass_source  ! mass source (kg/m^3)*(m/sec)
     real, dimension(:,:,:),   ALLOCATABLE :: mass_u       ! mass per area (kg/m^2) in a velocity column
     real, dimension(:,:,:),   ALLOCATABLE :: thicku       ! thickness on U-cell (metre) from z=eta_u to z=-H.

  end type ocean_thickness_type


  type, public :: ocean_grid_type
     character(len=32) :: name

! geometry and topology and rotation
     logical                            :: cyclic_x          ! true if domain is cyclic in the i direction
     logical                            :: cyclic_y          ! true if domain is cyclic in the j direction
     logical                            :: tripolar          ! folded connectivity at "top" row w/i bipolar Arctic
     logical                            :: mosaic            ! true when using a mosaic grid
     logical                            :: beta_plane        ! beta plane Cartesian
     logical                            :: f_plane           ! f-plane Cartesian
     real                               :: f_plane_latitude  ! latitude where f_plane is centered
     real, dimension(:,:), ALLOCATABLE :: f         ! coriolis parameter at u-cell points (sec^-1)
     real, dimension(:,:), ALLOCATABLE :: fstar     ! horizontal coriolis parameter at u-cell points (sec^-1)
     real, dimension(:,:), ALLOCATABLE :: beta      ! df/dy at u-cell points (1/(sec*m))
     real, dimension(:,:), ALLOCATABLE :: beta_eff  ! df/dy plus topographic beta at u-cell (1/(sec*m))

! vertical grid information (time independent)
     integer                               :: nk           ! number of vertical grid points
     integer, dimension(:,:), ALLOCATABLE :: kmt     ! number of t-levels
     integer, dimension(:,:), ALLOCATABLE :: kmu     ! number of u-levels

     real,    dimension(:),   ALLOCATABLE :: zt      ! distance from surface to grid point in level k (m)
     real,    dimension(:),   ALLOCATABLE :: zw      ! distance from surface down to bottom of level k (m)
     real,    dimension(:),   ALLOCATABLE :: dzt     ! initial vertical resolution of T or U grid cells (m)
     real,    dimension(:),   ALLOCATABLE :: dztlo   ! z-distance (m) from T-cell point to bottom of T-cell
     real,    dimension(:),   ALLOCATABLE :: dztup   ! z-distance (m) from T-cell point to top of T-cell
     real,    dimension(:),   ALLOCATABLE :: dzw     ! initial vertical resolution of W grid cells (m)
     real,    dimension(:),   ALLOCATABLE :: dzwr    ! reciprocal of dzw (W cell vertical resolution)

     real,    dimension(:),   ALLOCATABLE :: st      ! s-distance from surface to grid point in level k
     real,    dimension(:),   ALLOCATABLE :: sw      ! s-distance from surface down to bottom of level k
     real,    dimension(:),   ALLOCATABLE :: dst     ! initial s-vertical resolution of T or U grid cells
     real,    dimension(:),   ALLOCATABLE :: dstlo   ! s-distance (s-units) from T-cell point to bottom of T-cell
     real,    dimension(:),   ALLOCATABLE :: dstup   ! s-distance (s-units) from T-cell point to top of T-cell
     real,    dimension(:),   ALLOCATABLE :: dsw     ! initial s-vertical resolution of W grid cells

     real,    dimension(:,:), ALLOCATABLE :: fracdz  ! fractional distance between grid point & cell top/bot
     real,    dimension(:,:), ALLOCATABLE :: ht      ! depth to bottom of ocean (m) on t-cells
     real,    dimension(:,:), ALLOCATABLE :: htr     ! inverse depth to bottom of ocean (m^-1) on t-cells
     real,    dimension(:,:), ALLOCATABLE :: hu      ! depth to bottom of ocean (m) on u-cells
     real,    dimension(:,:), ALLOCATABLE :: dht_dx  ! d(ht)/dx on u-cells (m/m) at time tau
     real,    dimension(:,:), ALLOCATABLE :: dht_dy  ! d(ht)/dy on u-cells (m/m) at time tau
     real,    dimension(:,:), ALLOCATABLE :: gradH   ! sqrt(dht_dx**2+dht_dyx**2) on u-cells (m/m) at time tau

! horizontal grid information (time independent)
     integer                            :: ni, nj           ! global points in the two horizontal directions
     real, dimension(:,:), ALLOCATABLE :: xt          ! longitude of the T grid points in degrees
     real, dimension(:,:), ALLOCATABLE :: xu          ! longitude of the U grid points in degrees
     real, dimension(:,:), ALLOCATABLE :: yt          ! latitude of the T grid points in degrees
     real, dimension(:,:), ALLOCATABLE :: yu          ! latitude of the U grid points in degrees
     real, dimension(:,:), ALLOCATABLE :: phiu        ! latitude of U grid point in radians
     real, dimension(:,:), ALLOCATABLE :: phit        ! latitude of T grid point in radians
     real, dimension(:,:), ALLOCATABLE :: h1t         ! metric factors in i grid direction
     real, dimension(:,:), ALLOCATABLE :: h1u         ! metric factors in j grid jirection
     real, dimension(:,:), ALLOCATABLE :: h2t         ! metric factors in i grid direction
     real, dimension(:,:), ALLOCATABLE :: h2u         ! metric factors in j grid jirection
     real, dimension(:,:), ALLOCATABLE :: dh2dx       ! (1/delta_y)*d(delta_y)/dx (1/m)
     real, dimension(:,:), ALLOCATABLE :: dh1dy       ! (1/delta_x)*d(delta_x)/dy (1/m)
     real, dimension(:,:), ALLOCATABLE :: dxt         ! longitudinal width of T-cells at grid point (m)
     real, dimension(:,:), ALLOCATABLE :: dxu         ! longitudinal width of U-cells at grid point (m)
     real, dimension(:,:), ALLOCATABLE :: dyt         ! latitudinal width of T-cells at grid point (m)
     real, dimension(:,:), ALLOCATABLE :: dyu         ! latitudinal width of U-cells at grid point (m)
     real, dimension(:,:), ALLOCATABLE :: dau         ! area of U-cells (m^2)
     real, dimension(:,:), ALLOCATABLE :: dat         ! area of T-cells (m^2)
     real, dimension(:,:), ALLOCATABLE :: dxte        ! i-width between i+1 and i points in T-cells (m)
     real, dimension(:,:), ALLOCATABLE :: dxtn        ! i-width of north face of T-cells (m)
     real, dimension(:,:), ALLOCATABLE :: dyte        ! j-width of east  face of T-cells (m)
     real, dimension(:,:), ALLOCATABLE :: dytn        ! j-width between j+1 and j points in T-cells (m)
     real, dimension(:,:), ALLOCATABLE :: dxue        ! i-width between i+1 and i points in U-cells (m)
     real, dimension(:,:), ALLOCATABLE :: dxun        ! i-width of north face of U-cells (m)
     real, dimension(:,:), ALLOCATABLE :: dyue        ! j-width of east  face of U-cells (m)
     real, dimension(:,:), ALLOCATABLE :: dyun        ! j-width between j+1 and j points in U-cells (m)
     real, dimension(:,:), ALLOCATABLE :: datnr       ! reciprocal area at north face of T-cell
     real, dimension(:,:), ALLOCATABLE :: dater       ! reciprocal area at east face of T-cell
     real, dimension(:,:), ALLOCATABLE :: dun         ! width from grid point to north face of U-cells (m)
     real, dimension(:,:), ALLOCATABLE :: dus         ! width from grid point to south face of U-cells (m)
     real, dimension(:,:), ALLOCATABLE :: duw         ! width from grid point to west  face of U-cells (m)
     real, dimension(:,:), ALLOCATABLE :: due         ! width from grid point to east  face of U-cells (m)
     real, dimension(:,:), ALLOCATABLE :: dtn         ! width from grid point to north face of T-cells (m)
     real, dimension(:,:), ALLOCATABLE :: dts         ! width from grid point to south face of T-cells (m)
     real, dimension(:,:), ALLOCATABLE :: dtw         ! width from grid point to west  face of T-cells (m)
     real, dimension(:,:), ALLOCATABLE :: dte         ! width from grid point to east  face of T-cells (m)
     real, dimension(:,:), ALLOCATABLE :: dxtr        ! 1/dxt
     real, dimension(:,:), ALLOCATABLE :: dxur        ! 1/dxu
     real, dimension(:,:), ALLOCATABLE :: dytr        ! 1/dyt
     real, dimension(:,:), ALLOCATABLE :: dyur        ! 1/dyu
     real, dimension(:,:), ALLOCATABLE :: daur        ! 1/[area of U-cells (m^2)]
     real, dimension(:,:), ALLOCATABLE :: datr        ! 1/[area of T-cells (m^2)]
     real, dimension(:,:), ALLOCATABLE :: dxter       ! 1/dxte
     real, dimension(:,:), ALLOCATABLE :: dytnr       ! 1/dytn
     real, dimension(:,:), ALLOCATABLE :: dxuer       ! 1/dxue
     real, dimension(:,:), ALLOCATABLE :: dxunr       ! 1/dxun
     real, dimension(:,:), ALLOCATABLE :: dyuer       ! 1/dyue
     real, dimension(:,:), ALLOCATABLE :: dyunr       ! 1/dyun
     real, dimension(:,:), ALLOCATABLE :: dyue_dxuer  ! dyue/dxue
     real, dimension(:,:), ALLOCATABLE :: dxun_dyunr  ! dxun/dyun

! land/sea masks
     real, dimension(:,:),   ALLOCATABLE :: obc_tmask    ! land/sea mask for T cell diagnostics with OBC
     real, dimension(:,:),   ALLOCATABLE :: obc_umask    ! land/sea mask for U cell diagnostics with OBC
     real, dimension(:,:,:), ALLOCATABLE :: tmask        ! land/sea mask for T cells based on s-coordinate
     real, dimension(:,:,:), ALLOCATABLE :: umask        ! land/sea mask for U cells based on s-coordinate
     real, dimension(:,:,:), ALLOCATABLE :: tmask_depth  ! based on depth-based vert_coordinate
     real, dimension(:,:,:), ALLOCATABLE :: umask_depth  ! based on depth-based vert_coordinate

! grid areas and volumes
     real                              :: tcellv          ! initial T cell volume m^3 (entire ocean)
     real                              :: ucellv          ! initial U cell volume m^3 (entire ocean)
     real                              :: tcellsurf       ! T cell surface area (k=1) (bitwise reproducible)
     real                              :: ucellsurf       ! U cell surface area (k=1) (bitwise reproducible)
     real, dimension(:), ALLOCATABLE  :: tcella     ! T cell surface area m^2 (entire ocean)
     real, dimension(:), ALLOCATABLE  :: ucella     ! U cell surface area m^2 (entire ocean)

! model grid information
     integer :: wet_t_points   ! total number of wet tracer points
     integer :: wet_u_points   ! total number of wet velocity points
     integer :: total_t_points ! total number of wet or dry tracer points

! sine and cosine of rotation angles (clockwise) of velocity for tripolar
     real, dimension(:,:), ALLOCATABLE :: sin_rot    
     real, dimension(:,:), ALLOCATABLE :: cos_rot    

! 1-d grid coordinates for COARDS NetCDF files
     real, dimension(:), ALLOCATABLE  :: grid_x_t  
     real, dimension(:), ALLOCATABLE  :: grid_y_t  
     real, dimension(:), ALLOCATABLE  :: grid_x_u  
     real, dimension(:), ALLOCATABLE  :: grid_y_u  

! axes id for diagnostic manager
     integer, dimension(3)  :: tracer_axes        
     integer, dimension(3)  :: vel_axes_uv         
     integer, dimension(3)  :: vel_axes_wu    
     integer, dimension(3)  :: vel_axes_wt    
     integer, dimension(3)  :: tracer_axes_wt 
     integer, dimension(3)  :: tracer_axes_flux_x  
     integer, dimension(3)  :: tracer_axes_flux_y  
     integer, dimension(3)  :: vel_axes_flux_x    
     integer, dimension(3)  :: vel_axes_flux_y    

! axes id for diagnostic manager, appropriate
! when with to remap native vertical fields
! to depth or pressure levels.  Appropropriate
! when vert_coordinate == ZSIGMA or PSIGMA, or other
! vertical coordinats whose iso-surfaces are
! not quasi-horizontal
     integer, dimension(3)  :: tracer_axes_depth        
     integer, dimension(3)  :: vel_axes_uv_depth
     integer, dimension(3)  :: vel_axes_wu_depth    
     integer, dimension(3)  :: vel_axes_wt_depth
     integer, dimension(3)  :: tracer_axes_wt_depth
     integer, dimension(3)  :: tracer_axes_flux_x_depth
     integer, dimension(3)  :: tracer_axes_flux_y_depth
     integer, dimension(3)  :: vel_axes_flux_x_depth
     integer, dimension(3)  :: vel_axes_flux_y_depth


  end type ocean_grid_type
  
  type, public :: ocean_domain_type
     type(domain2d) :: domain2d           ! fms variable, used by mpp routines
     integer :: isc, iec, jsc, jec        ! computational domain indices
     integer :: isd, ied, jsd, jed        ! local indices, consistent with domain2d
     integer :: isg, ieg, jsg, jeg        ! global indices
     integer :: isa, iea, jsa, jea        ! active indices (for minimizing comm2d calls)
     integer :: xhalo, yhalo              ! halo sizes
     integer :: xflags, yflags, layout(2) ! options to mpp_define_domains
     integer :: ioff, joff                ! offset to get absolute indices when MOM4_STATIC_ARRAYS (0 otherwise)
     integer :: io_layout(2)              ! options to define io_domain.
     integer :: x_cyclic_offset           ! offset applied to x-direction cyclic boundary condition
     integer :: y_cyclic_offset           ! offset applied to y-direction cyclic boundary condition
     logical, pointer :: maskmap(:,:) =>NULL() ! option to mpp_define_domains
  end type ocean_domain_type

  type, public :: ocean_time_type
     type(time_type) :: model_time     ! fms variable
     type(time_type) :: time_step      ! ocean tracer timestep
     type(time_type) :: Time_init      ! time of initial conditions
     integer :: calendar               ! calendar type defined by time_manager_mod
     logical :: init                   ! true at beginning of run (initial condition time)
     integer :: itt                    ! timestep counter measured relative to time at restart
     integer :: itt0                   ! timestep counter measured relative to initial condition time
     integer :: taum1, tau, taup1      ! time level indices
     integer :: tau_m2, tau_m1, tau_m0 ! time level indices for Adams-Bashforth velocity advection
  end type ocean_time_type

  type, public :: ocean_adv_vel_type
     real, ALLOCATABLE, dimension(:,:,:)  :: uhrho_et    ! rho_dzu weight advect vel (kg/(m*s)) on T-cell i-face
     real, ALLOCATABLE, dimension(:,:,:)  :: vhrho_nt    ! rho_dzu weight advect vel (kg/(m*s)) on T-cell j-face
     real, ALLOCATABLE, dimension(:,:,:)  :: uhrho_eu    ! remapped uhrho_et (kg/(m*s)) onto i-face of U-cell
     real, ALLOCATABLE, dimension(:,:,:)  :: vhrho_nu    ! remapped vhrho_nt (kg/(m*s)) onto j-face of U-cell
     real, ALLOCATABLE, dimension(:,:,:)  :: wrho_bt     ! rho weight (kg/(m^2*s)) vert advect vel on T-bottom
     real, ALLOCATABLE, dimension(:,:,:)  :: wrho_bu     ! remapped wrho_bt onto U-bottom
     real, ALLOCATABLE, dimension(:,:,:)  :: diverge_t   ! divergence on T-cell of horiz momentum per mass (kg/m3)*(m/s)
     real, ALLOCATABLE, dimension(:,:,:)  :: diverge_u   ! divergence on U-cell of horiz momentum per mass (kg/m3)*(m/s)
  end type ocean_adv_vel_type


  type, public ::  ocean_density_type
     real, ALLOCATABLE, dimension(:,:,:,:) :: rho                ! in situ density (kg/m^3) at time levels
     real, ALLOCATABLE, dimension(:,:,:)   :: rho_fresh          ! in situ fresh water density (kg/m^3) at tau
     real, ALLOCATABLE, dimension(:,:,:)   :: pressure_at_depth  ! hydrostatic pressure (including patm)
     real, ALLOCATABLE, dimension(:,:,:)   :: drhodT             ! partial rho wrt theta (kg/(m^3 C)
     real, ALLOCATABLE, dimension(:,:,:)   :: drhodS             ! partial rho wrt salinity (kg/(m3 psu)
     real, ALLOCATABLE, dimension(:,:,:)   :: drhodP             ! partial rho wrt pressure (kg/(m3 Pa)
     real, ALLOCATABLE, dimension(:,:,:)   :: drhodz_wt          ! d(neutral rho)/dz (kg/m^4) at W-point
     real, ALLOCATABLE, dimension(:,:,:)   :: drhodz_zt          ! d(neutral rho)/dz (kg/m^4) at T-point
     real, ALLOCATABLE, dimension(:,:,:)   :: dTdz_zt            ! partial theta wrt z  (C/m) at T-point
     real, ALLOCATABLE, dimension(:,:,:)   :: dSdz_zt            ! partial salinity wrt z  (psu/m) at T-point
     real, ALLOCATABLE, dimension(:,:,:)   :: potrho             ! potential density (kg/m^3)
     real, ALLOCATABLE, dimension(:,:,:)   :: neutralrho         ! neutral density (kg/m^3)
     real, ALLOCATABLE, dimension(:)       :: potrho_ref         ! partition vertical into potrho classes
     real, ALLOCATABLE, dimension(:)       :: neutralrho_ref     ! partition vertical into neutral density classes
     real, ALLOCATABLE, dimension(:)       :: theta_ref          ! partition vertical into theta classes
     integer, dimension(3)                  :: potrho_axes             ! axis ids for diagnosing potential density
     integer, dimension(3)                  :: neutralrho_axes         ! axis ids for diagnosing neutral density
     integer, dimension(3)                  :: theta_axes              ! axis ids for potential temperature
  end type ocean_density_type
  
  type, public :: ocean_prog_tracer_type
     character(len=32)  :: name
     character(len=32)  :: units
     character(len=32)  :: type
     character(len=128) :: longname

     logical :: use_only_advection      ! for testing purposes, evolve using ONLY advection
     logical :: neutral_physics_limit   ! revert neutral physics to horz diffusion where tracer out of bounds
     logical :: complete                ! to determine if ready to do mpp updates

     integer :: sfc_flux_id=-1          ! index for time_interp_external
     integer :: horz_advect_scheme=-1   ! id for horizontal advection scheme
     integer :: vert_advect_scheme=-1   ! id for vertical advection scheme
     integer :: id_obc                  ! id to identify tracer in OBC-subroutines
     integer :: ppm_hlimiter=1          ! Limiter for use with PPM in horizontal
     integer :: ppm_vlimiter=1          ! Limiter for use with PPM in vertical

     real, ALLOCATABLE, dimension(:,:,:,:) :: field           ! tracer concentration at 3 time levels
     real, ALLOCATABLE, dimension(:,:,:)   :: th_tendency     ! thickness weighted tracer tendency
     real, ALLOCATABLE, dimension(:,:,:)   :: tendency        ! for diagnostics: tendency concentration [concentration/sec]
     real, ALLOCATABLE, dimension(:,:,:)   :: source          ! tracer source [=tracer concentration per time]
     real, ALLOCATABLE, dimension(:,:)     :: eta_smooth      ! tendency from eta_t smoother
     real, ALLOCATABLE, dimension(:,:)     :: pbot_smooth     ! tendency from pbot_t smoother

     real, ALLOCATABLE, dimension(:,:,:)   :: wrk1                 ! work array
     real, ALLOCATABLE, dimension(:,:,:)   :: tmask_limit          ! to limit advective and/or neutral physics flux
     real, ALLOCATABLE, dimension(:,:,:)   :: K33_implicit         ! m^2/sec vert-diffusivity from neutral diffusion
     real, ALLOCATABLE, dimension(:,:,:)   :: radiation            ! radiation absorbed within a cell [W/m^2]
     real, ALLOCATABLE, dimension(:,:)     :: stf                  ! surface tracer flux [rho*m/sec*tracer concen]
     real, ALLOCATABLE, dimension(:,:)     :: btf                  ! bottom tracer flux [rho*m/sec*tracer concen]
     real, ALLOCATABLE, dimension(:,:)     :: tpme                 ! tracer concentration in precip-evap
     real, ALLOCATABLE, dimension(:,:)     :: triver               ! tracer concentration in river(=runoff+calving)
     real, ALLOCATABLE, dimension(:,:)     :: trunoff              ! tracer concentration in river runoff
     real, ALLOCATABLE, dimension(:,:)     :: tcalving             ! tracer concentration in calving lang ice
     real, ALLOCATABLE, dimension(:,:)     :: runoff_tracer_flux   ! tracer flux in liquid runoff (e.g., kg*degC/(m^2 s) for temp)
     real, ALLOCATABLE, dimension(:,:)     :: calving_tracer_flux  ! tracer flux in solid runoff (e.g., kg*psu/(m^2 s)  for salinity)
     real, ALLOCATABLE, dimension(:,:)     :: riverdiffuse         ! where to enhance diff_cbt according to rivers
     real, ALLOCATABLE, dimension(:,:)     :: flux_int             ! integrated sfc tracer flux for diagnostics

! variables for prather's second order moment advection
     logical :: psom_limit                             ! controls whether a limiter is placed on the prather flux
     real, dimension(:,:,:), ALLOCATABLE :: s0   ! zeroth moment (mean)
     real, dimension(:,:,:), ALLOCATABLE :: sx   ! 1st moment in i direction
     real, dimension(:,:,:), ALLOCATABLE :: sxx  ! 2nd moment in i direction
     real, dimension(:,:,:), ALLOCATABLE :: sy   ! 1st moment in j direction
     real, dimension(:,:,:), ALLOCATABLE :: syy  ! 2nd moment in j direction
     real, dimension(:,:,:), ALLOCATABLE :: sz   ! 1st moment in k direction
     real, dimension(:,:,:), ALLOCATABLE :: szz  ! 2nd moment in k direction
     real, dimension(:,:,:), ALLOCATABLE :: sxy  ! 2nd moment for coupling the i and j directions
     real, dimension(:,:,:), ALLOCATABLE :: sxz  ! 2nd moment for coupling the i and k directions
     real, dimension(:,:,:), ALLOCATABLE :: syz  ! 2nd moment for coupling the j and k directions

     type(obc_flux), ALLOCATABLE, dimension(:) :: otf       ! flux through open boundaries, allocate nobc

     real                              :: conversion            ! conversion between  dimensions
     real                              :: offset                ! offset in dimensions (e.g., Celsius to Kelvin)
     real                              :: min_tracer            ! min acceptable value used for error checking
     real                              :: max_tracer            ! max acceptable value used for error checking
     real                              :: min_range             ! min value used for calls to diagnostic manager
     real                              :: max_range             ! max value used for calls to diagnostic manager
     real                              :: min_tracer_limit      ! min value used to limit quicker & neutral fluxes
     real                              :: max_tracer_limit      ! max value used to limit quicker & neutral fluxes
     real                              :: min_flux_range        ! min and max values used for flux diagnostics
     real                              :: max_flux_range        ! min and max values used for flux diagnostics
     real                              :: const_init_value      ! value used to initialize constant tracer
     logical                           :: const_init_tracer     ! false (default) if the tracer must exist in the restart file
!   otherwise will initialize with const_init_value
     character(len=32)                 :: flux_units            ! units for the tracer flux
     character(len=128)                :: restart_file          ! name for restart file
  end type ocean_prog_tracer_type

  type, public :: ocean_diag_tracer_type
     character(len=32)  :: name, units, type
     character(len=128) :: longname
     real, dimension(:,:,:), pointer  :: field       ! tracer concentration at single time level
     real :: conversion                              ! conversion between dimensions
     real :: offset                                  ! offset in dimensions (e.g., Celsius to Kelvin)
     real :: min_tracer, max_tracer                  ! min and max acceptable values used for error checking
     real :: min_range, max_range                    ! min and max values used for diagnostics
     logical :: const_init_tracer                    ! false (default) if the tracer must exist in the restart file
!   otherwise will initialize with const_init_value
     character(len=128) :: restart_file              ! name for restart file
     real               :: const_init_value          ! value used to initialize constant tracer
  end type ocean_diag_tracer_type

  type, public :: ocean_velocity_type
     logical                                  :: bmf_implicit      ! is true when time stepping bmf implicitly
     real, ALLOCATABLE, dimension(:,:,:,:,:) :: u                ! horz velocity (m/s) in i,j directions at 3 time levels
     real, ALLOCATABLE, dimension(:,:,:)     :: smf              ! momentum flux per mass into ocean surface (N/m^2)
     real, ALLOCATABLE, dimension(:,:,:)     :: bmf              ! momentum flux per mass into ocean bottom  (N/m^2)
     real, ALLOCATABLE, dimension(:,:)       :: gamma            ! dimensionful bottom drag coefficient (kg/(m^2 sec))
     real, ALLOCATABLE, dimension(:,:)       :: rossby_radius    ! first baroclinic rossby radius (m)
     real, ALLOCATABLE, dimension(:,:,:,:)   :: press_force      ! rho*dz*horz (i,j)-directed press force (N/m^2)
     real, ALLOCATABLE, dimension(:,:,:,:)   :: accel            ! rho*dz*velocity (i,j)-directed acceleration (N/m^2)
     real, ALLOCATABLE, dimension(:,:,:,:)   :: vfrict_impl      ! rho*dz*vertical friction (N/m^2)
     real, ALLOCATABLE, dimension(:,:,:,:)   :: source           ! thickness*density weighted velocity source/sink (N/m^2)
     real, ALLOCATABLE, dimension(:,:,:,:)   :: wrkv             ! work array
     real, ALLOCATABLE, dimension(:,:,:,:,:) :: advection        ! rho*dz*velocity advection tendency (N/m^2)
     real, ALLOCATABLE, dimension(:,:,:)     :: lap_friction_bt  ! friction just on barotropic (N/m^2)
     real, ALLOCATABLE, dimension(:,:,:)     :: bih_friction_bt  ! friction just on barotropic (N/m^2)
  end type ocean_velocity_type


  type, public :: ocean_external_mode_type
     real, ALLOCATABLE, dimension(:,:,:)   :: eta_t         ! surface height on tracer cell center (m)
     real, ALLOCATABLE, dimension(:,:,:)   :: eta_u         ! surface height on tracer cell center (m)
     real, ALLOCATABLE, dimension(:,:,:)   :: eta_t_bar     ! eta_t time averaged over ext-mode time steps (m)
     real, ALLOCATABLE, dimension(:,:)     :: deta_dt       ! surface height time tendency on t-cell (m/s)

     real, ALLOCATABLE, dimension(:,:,:)   :: pbot_t      ! bottom pressure on tracer cell center (Pa)
     real, ALLOCATABLE, dimension(:,:,:)   :: pbot_u      ! bottom pressure on velocity cell center (Pa)
     real, ALLOCATABLE, dimension(:,:,:)   :: anompb      ! pbot_t_rho0*grav*ht (Pa) = anomalous bottom pressure (m^2/s^2)
     real, ALLOCATABLE, dimension(:,:,:)   :: anompb_bar  ! pbot_t-rho0*grav*ht (Pa) time avg over ext-mode time steps
     real, ALLOCATABLE, dimension(:,:)     :: dpbot_dt    ! bottom pressure time tendency on tracer cell (Pa/s)

     real, ALLOCATABLE, dimension(:,:,:)   :: patm_t            ! ice plus atmospheric press on tracer cell (Pa)
     real, ALLOCATABLE, dimension(:,:)     :: patm_for_sea_lev  ! ice plus atmospheric press on tracer cell, passed to coupler (Pa)
     real, ALLOCATABLE, dimension(:,:)     :: patm_u            ! ice plus atmospheric press on velocity cell (Pa)
     real, ALLOCATABLE, dimension(:,:)     :: dpatm_dt          ! time tendency of patm on T-cell(Pa/s)

     real, ALLOCATABLE, dimension(:,:,:)   :: forcing_bt  ! depth integrated forcing of barotropic (w/o coriolis)
     real, ALLOCATABLE, dimension(:,:,:,:) :: udrho       ! vertically integrated & rho wghted horz velocity (kg/m^3)*(m^2/s)
     real, ALLOCATABLE, dimension(:,:,:)   :: conv_rho_ud_t   ! convergence of sum_k(rho*dzt*u) on T-cell (kg/m^3)*(m/s)
     real, ALLOCATABLE, dimension(:,:)     :: ps              ! surface pressure (pressure at z=0 due to eta_t) at time tau
     real, ALLOCATABLE, dimension(:,:,:)   :: grad_ps         ! rho0r * horizontal surface pressure gradient at time tau
     real, ALLOCATABLE, dimension(:,:,:)   :: grad_anompb     ! gradient of anompb (Pa/m)
     real, ALLOCATABLE, dimension(:,:,:)   :: press_force     ! pressure force/area (N/m^2) updated each barotropic time step

     real, ALLOCATABLE, dimension(:,:)     :: source          ! density weighted vertical integral of mass source (kg/m^2/sec)
     real, ALLOCATABLE, dimension(:,:)     :: eta_smooth      ! (kg/m^3)*(m/s) from eta_t smoother
     real, ALLOCATABLE, dimension(:,:)     :: pbot_smooth     ! (kg/m^3)*(m/s) from pbot_t smoother

     real, ALLOCATABLE, dimension(:,:,:)   :: eta_nonbouss    ! diagnosed eta (m) including steric effects
     real, ALLOCATABLE, dimension(:,:,:)   :: eta_nonsteric   ! diagnosed piece of eta_nonbouss (m) from non-steric effects
     real, ALLOCATABLE, dimension(:,:,:)   :: eta_steric      ! diagnosed eta_nonbouss (m) from steric effects
     real, ALLOCATABLE, dimension(:,:,:)   :: eta_dynamic     ! diagnosed eta_nonbouss (m) from "dynamic" effects
     real, ALLOCATABLE, dimension(:,:,:)   :: eta_water       ! diagnosed eta_nonbouss (m) from water forcing at boundaries
     real, ALLOCATABLE, dimension(:,:,:)   :: eta_source      ! diagnosed eta_nonbouss (m) from source term
     real, ALLOCATABLE, dimension(:,:,:)   :: eta_surf_temp   ! diagnosed eta_nonbouss (m) arising from surface temp flux
     real, ALLOCATABLE, dimension(:,:,:)   :: eta_surf_salt   ! diagnosed eta_nonbouss (m) arising from surface salt flux
     real, ALLOCATABLE, dimension(:,:,:)   :: eta_surf_water  ! diagnosed eta_nonbouss (m) arising from surface water flux
     real, ALLOCATABLE, dimension(:,:,:)   :: eta_bott_temp   ! diagnosed eta_nonbouss (m) arising from bottom temp flux
  end type ocean_external_mode_type


! types used by neutral physics
  type, public :: tracer_2d_type
    real, ALLOCATABLE, dimension(:,:)   :: field  
  end type tracer_2d_type

  type, public :: tracer_3d_0_nk_type
    real, ALLOCATABLE, dimension(:,:,:) :: field  
  end type tracer_3d_0_nk_type

  type, public :: tracer_3d_1_nk_type
    real, ALLOCATABLE, dimension(:,:,:) :: field  
  end type tracer_3d_1_nk_type


! for gotm vertical mixing scheme
  type, public :: ocean_gotm_type
     character(len=32)  :: name
     character(len=32)  :: units
     character(len=128) :: longname
     real               :: min_value ! minimum value
     real               :: max_value ! maximum value
     real, ALLOCATABLE, dimension(:,:,:,:) :: field   ! scalar at 2 time levels
  end type ocean_gotm_type

! advection tendency for GOTM scalar fields
  type, public  :: advect_gotm_type  
    real, dimension(:,:,:), pointer :: field => NULL() 
  end type advect_gotm_type



!############################################################################################
! end of STATIC_MEMORY

  type, public :: ice_ocean_boundary_type
!--> esm insertion (gfs fields  to be passed on to ocean)
	real, pointer, dimension(:,:) :: au_flux      =>NULL() ! i-direction wind stress (Pa)
	real, pointer, dimension(:,:) :: av_flux      =>NULL() ! j-direction wind stress (Pa)
	real, pointer, dimension(:,:) :: at_flux      =>NULL() ! sensible heat flux (W/m2)
	real, pointer, dimension(:,:) :: aq_flux      =>NULL() ! specific humidity flux (kg/m2/s)
	real, pointer, dimension(:,:) :: alw_flux     =>NULL() ! long wave radiation (W/m2)
	real, pointer, dimension(:,:) :: asw_flux     =>NULL() ! short wave radiation (W/m2)
	real, pointer, dimension(:,:) :: ta1_ocn      =>NULL() ! air temparature (t_bot) (K)
!<-- esm insertion

     real, pointer, dimension(:,:) :: u_flux          =>NULL() ! i-directed wind stress into ocean (Pa)
     real, pointer, dimension(:,:) :: v_flux          =>NULL() ! j-directed wind stress into ocean (Pa)
     real, pointer, dimension(:,:) :: t_flux          =>NULL() ! sensible heat flux into ocean (W/m2)
     real, pointer, dimension(:,:) :: q_flux          =>NULL() ! specific humidity flux (kg/m2/s)
     real, pointer, dimension(:,:) :: salt_flux       =>NULL() ! salt flux (kg/m2/s)
     real, pointer, dimension(:,:) :: lw_flux         =>NULL() ! long wave radiation (W/m2)
     real, pointer, dimension(:,:) :: sw_flux_vis_dir =>NULL() ! direct visible sw radiation (W/m2)
     real, pointer, dimension(:,:) :: sw_flux_vis_dif =>NULL() ! diffuse visible sw radiation (W/m2)
     real, pointer, dimension(:,:) :: sw_flux_nir_dir =>NULL() ! direct near IR sw radiation (W/m2)
     real, pointer, dimension(:,:) :: sw_flux_nir_dif =>NULL() ! diffuse near IR sw radiation (W/m2)
     real, pointer, dimension(:,:) :: lprec           =>NULL() ! mass flux of liquid precip (kg/m2/s)
     real, pointer, dimension(:,:) :: fprec           =>NULL() ! mass flux of frozen precip (kg/m2/s)
     real, pointer, dimension(:,:) :: runoff          =>NULL() ! mass flux of liquid runoff (kg/m2/s)
     real, pointer, dimension(:,:) :: calving         =>NULL() ! mass flux of frozen runoff (kg/m2/s)
     real, pointer, dimension(:,:) :: runoff_hflx     =>NULL() ! heat flux, relative to 0C, of liquid land water entering ocean (W/m2)
     real, pointer, dimension(:,:) :: calving_hflx    =>NULL() ! heat flux, relative to 0C, of frozen land water entering ocean (W/m2)
     real, pointer, dimension(:,:) :: p               =>NULL() ! pressure of overlying sea ice and atmosphere (Pa)
     integer :: xtype                                          ! REGRID, REDIST or DIRECT

     type(coupler_2d_bc_type)      :: fluxes                   ! array of fields used for additional tracers
  end type ice_ocean_boundary_type


! for communication with FMS coupler and ESMF coupler
  type, public ::  ocean_public_type 
     type(domain2d) :: Domain

! ESMF requires these arrays to be pointers
     real, pointer, dimension(:,:)    :: t_surf  =>NULL() ! SST on t-cell (degrees Kelvin)
     real, pointer, dimension(:,:)    :: s_surf  =>NULL() ! SSS on t-cell (psu)
     real, pointer, dimension(:,:)    :: u_surf  =>NULL() ! i-directed surface ocean velocity on u-cell (m/s)
     real, pointer, dimension(:,:)    :: v_surf  =>NULL() ! j-directed surface ocean velocity on u-cell (m/s)
     real, pointer, dimension(:,:)    :: sea_lev =>NULL() ! eta_t + patm/(rho0*grav) (m)
     real, pointer, dimension(:,:)    :: frazil  =>NULL() ! accumulated heating (J/m^2) from
! frazil formation in the ocean
     real, pointer, dimension(:,:)    :: area    =>NULL() ! T-cell area.
     logical, pointer, dimension(:,:) :: maskmap =>NULL()! A pointer to an array indicating which
! logical processors are actually used for
! the ocean code. The other logical
! processors would be all land points and
! are not assigned to actual processors.
! This need not be assigned if all logical
! processors are used.
     integer, pointer, dimension(:) :: pelist  =>NULL()  ! Used for flux-exchange.
     integer                        :: avg_kount         ! Used for accumulating averages - can be omitted?
     logical                        :: is_ocean_pe       ! .true. on processors that run the ocean model.
     integer, dimension(3)          :: axes              ! for diagnostics
     type(coupler_2d_bc_type)       :: fields            ! array of fields used for additional tracers
  end type ocean_public_type


public ocean_types_init
 
contains 


!#######################################################################
! <SUBROUTINE NAME="ocean_types_init">
!
! <DESCRIPTION>
! Initialize the ocean types.
! </DESCRIPTION>
!
  subroutine ocean_types_init()

    if (module_is_initialized) then 
       call mpp_error( FATAL, '==>Error: ocean_types_init: module already initialized')
    endif
    module_is_initialized = .true.

    call write_version_number(version, tagname)

    return

  end subroutine ocean_types_init
! </SUBROUTINE> NAME="ocean_types_init"


end module ocean_types_mod


